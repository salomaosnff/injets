{"version":3,"sources":["../src/delayed.ts","../src/types.ts","../src/util.ts","../src/container.ts"],"names":["_wrap","_Delayed","factory","__privateAdd","__privateSet","cache","getValue","__privateGet","handler","method","_","args","__publicField","Delayed","delayed","ProviderMode","tokenName","token","isValueProvider","provider","isClassProvider","isFactoryProvider","providerModeIs","mode","_name","_export","_cache","_imported","_providers","_exported","_resolveProvider","resolveProvider_fn","_construct","construct_fn","_Container","options","container","tokenOrTokenList","includePrivate","ctor","__privateMethod","instance","dependencies","Container"],"mappings":"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","sourcesContent":["import type { Token } from './types';\n\nexport class Delayed<T = unknown> {\n  private static reflectMethods: ReadonlyArray<keyof ProxyHandler<object>> = [\n    'get',\n    'getPrototypeOf',\n    'setPrototypeOf',\n    'getOwnPropertyDescriptor',\n    'defineProperty',\n    'has',\n    'set',\n    'deleteProperty',\n    'apply',\n    'construct',\n    'ownKeys',\n  ];\n\n  #wrap: () => T;\n\n  constructor(factory: () => T) {\n    this.#wrap = factory;\n  }\n\n  createProxy(factory: (ctor: T) => T): T {\n    let cache: T;\n    const getValue = () => (cache ??= factory(this.#wrap()));\n    const handler: object = { };\n\n    for (const method of Delayed.reflectMethods) {\n      // @ts-expect-error Ignore index signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      handler[method] = (_: T, ...args: any[]) =>\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        (Reflect[method] as Function)(getValue(), ...args);\n    }\n\n    return new Proxy({}, handler) as T;\n  }\n}\n\n/**\n * Delay the resolution of a token.\n * @param factory Factory function to construct the token.\n * @returns Delayed token.\n * @example\n * const foo = container.resolve(delay(() => Foo));\n */\nexport function delayed<T extends Token>(factory: () => T): T {\n  return new Delayed(factory) as unknown as T;\n}\n","/** Class type. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Class<T, A extends Readonly<any[]> = any[]> = new (...args: A) => T\n\n/** Token of a provider. */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-unused-vars\nexport type Token<T = unknown> = {}\n\n/** Value of a token. */\nexport type TokenValue<T> = T extends Class<infer U> ? U : T extends Token<infer U> ? U : unknown\n\n/** Dependency list of a provider. */\nexport type DependencyList<T = Token> = Readonly<T[]>\n\nexport type DependencyValues<T> = T extends DependencyList ? {\n  [K in keyof T]: TokenValue<T[K]>\n} : unknown\n\n/** Provider of a token. */\nexport enum ProviderMode {\n  SINGLETON = 'SINGLETON',\n  TRANSIENT = 'TRANSIENT',\n}\n\nexport interface WithExport {\n  /** Export the token from the container. */\n  export?: boolean\n}\n\nexport interface WithInject<T extends DependencyList> {\n  /** Inject providers into this container. */\n  inject?: T\n}\n\nexport interface WithMode {\n  /** Provider mode. */\n  mode?: ProviderMode\n}\n\nexport interface WithToken<T> {\n  /** Token of the provider. */\n  token: Token<T>\n}\n\n/** Factory provider. */\nexport interface FactoryProvider<T = unknown, D extends DependencyList = DependencyList> extends WithToken<T>, WithExport, WithMode, WithInject<D> {\n  /** Factory function to construct the provider. */\n  useFactory(...args: D): T\n}\n\n/** Value provider. */\nexport interface ValueProvider<T = unknown> extends WithToken<T>, WithExport, WithMode {\n  /** Token of the provider. */\n  token: Token<T>\n\n  /** Value of the provider. */\n  useValue: T\n}\n\n/** Class provider. */\nexport interface ClassProvider<T = unknown, D extends Readonly<unknown[]> = []> extends Partial<WithToken<T>>, WithExport, WithMode {\n  /** Class type to construct the provider. */\n  useClass: Class<T, D>\n\n  /** Dependency list to inject into the class. */\n  inject?: {\n    [K in keyof D]: Token<D[K]>\n  }\n}\n\n/** Provider. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Provider<T = unknown, D extends DependencyList = any[]> = FactoryProvider<T, D> | ValueProvider<T> | ClassProvider<T, D>","import type { ClassProvider,\n  DependencyList,\n  FactoryProvider,\n  Provider,\n  ProviderMode,\n  Token,\n  ValueProvider } from './types';\n\n/** Get the name of a token. */\nexport function tokenName(token: Token) {\n  if (typeof token === 'function') {\n    return token.name;\n  }\n\n  return String(token);\n}\n\n/** Check if a provider is a value provider. */\nexport function isValueProvider(provider: Provider): provider is ValueProvider {\n  return 'useValue' in provider;\n}\n\n/** Check if a provider is a class provider. */\nexport function isClassProvider<T, D extends DependencyList>(\n  provider: Provider<T, D>,\n): provider is ClassProvider<T, D> {\n  return 'useClass' in provider;\n}\n\n/** Check if a provider is a factory provider. */\nexport function isFactoryProvider<T, D extends DependencyList>(\n  provider: Provider<T, D>,\n): provider is FactoryProvider<T, D> {\n  return 'useFactory' in provider;\n}\n\n/** Check if a provider is a class or factory provider. */\nexport function providerModeIs<M extends ProviderMode>(\n  provider: { mode?: ProviderMode },\n  mode: M,\n): provider is Provider & {\n  mode: M\n} {\n  return provider.mode === mode;\n}\n","import { Delayed } from './delayed';\nimport type { ClassProvider, DependencyList, DependencyValues, Provider, Token, TokenValue } from './types';\nimport { ProviderMode } from './types';\nimport { isClassProvider,\n  isFactoryProvider,\n  isValueProvider,\n  providerModeIs,\n  tokenName } from './util';\n\nexport interface ContainerOptions {\n  name?: string\n  isGlobal?: boolean\n  defaultExport?: boolean\n  imports?: Container[]\n  providers?: Provider[]\n}\n\nexport class Container<T extends Token = Token> {\n  #name: string;\n  #export: boolean;\n  #cache = new Map<Token, unknown>();\n  #imported = new Map<Token, Container>();\n  #providers = new Map<Token, Provider>();\n  #exported = new Set<Token>();\n\n  isGlobal: boolean;\n\n  static global = new Container({ name: 'global' });\n\n  #resolveProvider<U, D extends Readonly<T[]>>(provider: Provider<U, D>): U {\n    const token = provider.token ?? (provider as ClassProvider<U>).useClass;\n    const instance = this.#construct(provider);\n\n    if (providerModeIs(provider, ProviderMode.SINGLETON)) {\n      this.#cache.set(token, instance);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Resolve all tokens in a dependency list.\n   * @param tokens Dependency list.\n   * @param includePrivate Include private providers.\n   * @returns Resolved values.\n   * @throws {Error} If a provider is not found.\n   * @throws {TypeError} If a circular dependency is detected.\n   * @example\n   * const [foo, bar] = container.resolve([Foo, Bar]);\n   */\n  resolve<const U extends Readonly<T[]>>(tokens?:U, includePrivate?: boolean): DependencyValues<U>;\n  /**\n   * Resolve a token.\n   * @param token Token to resolve.\n   * @param includePrivate Include private providers.\n   * @returns Resolved value.\n   * @throws {Error} If a provider is not found.\n   * @throws {TypeError} If a circular dependency is detected.\n   * @example\n   * const foo = container.resolve(Foo);\n   * const bar = container.resolve(Bar);\n   */\n  resolve<const U extends T>(token: U, includePrivate?: boolean): TokenValue<U>;\n  resolve(tokenOrTokenList: Token | Token[], includePrivate?: boolean) {\n    if (Array.isArray(tokenOrTokenList)) {\n      return tokenOrTokenList.map(token => this.resolve(token, includePrivate));\n    }\n\n    const token = tokenOrTokenList;\n\n    if (typeof token === 'undefined') {\n      throw new TypeError(`Possible circular dependency detected in ${this.#name\n      } container.\nToken is undefined.\nTry to use \"delay(() => <token>)\" function to delay the resolution of the token.`);\n    }\n\n    if (token instanceof Delayed) {\n      return token.createProxy(ctor => this.resolve(ctor));\n    }\n\n    if (this.#cache.has(token)) {\n      return this.#cache.get(token);\n    }\n\n    if (this.#providers.has(token)) {\n      if (!includePrivate && !this.#exported.has(token)) {\n        throw new Error(\n          `Provider \"${tokenName(token)}\" is not exported from container \"${this.#name}\"`,\n        );\n      }\n      const provider = this.#providers.get(token)!;\n      return this.#resolveProvider(provider);\n    }\n\n    if (this.#imported.has(token)) {\n      const container = this.#imported.get(token)!;\n      return container.resolve(token);\n    }\n\n    try {\n      return Container.global.resolve(token);\n    }\n    catch {\n      // ignore\n    }\n\n    throw new Error(\n      `Provider \"${tokenName(token)}\" not found in container \"${this.#name}\"`,\n    );\n  }\n\n  /**\n   * Provide a token in the container.\n   * @param provider Provider to register.\n   * @throws {Error} If the provider is invalid.\n   * @example\n   * container.provide({ token: Foo, useClass: Foo });\n   * container.provide({ token: Bar, useValue: bar });\n   * container.provide({ token: Baz, useFactory: () => baz });\n   * container.provide({ token: Qux, useClass: Qux, inject: [Foo, Bar, Baz] });\n   */\n  provide<T, D extends DependencyList>(provider: Provider<T, D>) {\n    const token\n      = provider.token ?? (provider as ClassProvider).useClass;\n\n    if (isClassProvider(provider) || isFactoryProvider(provider)) {\n      provider.mode ??= ProviderMode.SINGLETON;\n    }\n\n    if (!token) {\n      throw new Error('Provider must have a token or a useClass property');\n    }\n\n    this.#providers.set(token, provider as Provider);\n\n    if (provider.export ?? this.#export) {\n      this.export(token);\n    }\n\n    if (this.isGlobal) {\n      Container.global.#imported.set(token, this);\n    }\n  }\n\n  /**\n   * Import all exported tokens from another container.\n   * @param container Container to import from.\n   * @example\n   * container.import(otherContainer);\n   * container.resolve(Foo); // Foo is exported from otherContainer\n   */\n  import(container: Container) {\n    for (const token of container.#exported) {\n      this.#imported.set(token, container);\n    }\n  }\n\n  /**\n   * Export a token from the container.\n   * @param token Token to export.\n   * @example\n   * container.export(Foo);\n   */\n  export(token: Token) {\n    if (this.#providers.has(token)) {\n      this.#exported.add(token);\n      return;\n    }\n\n    throw new Error(\n      `Cannot export \"${tokenName(token)}\" from container \"${this.#name\n      }\" because it is not registered`,\n    );\n  }\n\n  #construct<U, D extends DependencyList<T>>(provider: Provider<U, D>): U {\n    if (isClassProvider(provider)) {\n      const dependencies = this.resolve((provider.inject ?? []) as D, true);\n\n      return new provider.useClass(...dependencies as D);\n    }\n\n    if (isFactoryProvider(provider)) {\n      const dependencies = this.resolve(provider.inject ?? [], true);\n      return provider.useFactory(...dependencies as D);\n    }\n\n    if (isValueProvider(provider)) {\n      return provider.useValue;\n    }\n\n    throw new Error('Providers must be a class, factory, or value');\n  }\n\n  /**\n   * Create a new dependency injection container.\n   * @param options Container options.\n   * @example\n   * const container = new Container({\n   *  name: 'MyContainer', // recommended\n   *  imports: [OtherContainer],\n   *  providers: [\n   *   { token: Foo, useClass: Foo },\n   *  ]\n   * });\n   * container.resolve(Foo); // Foo\n   */\n  constructor(options: ContainerOptions = {}) {\n    this.isGlobal = options.isGlobal ?? false;\n    this.#name = options.name ?? this.constructor.name;\n    this.#export = options.defaultExport ?? true;\n\n    for (const container of options.imports ?? []) {\n      this.import(container);\n    }\n\n    for (const provider of options.providers ?? []) {\n      this.provide(provider);\n    }\n  }\n}\n"]}