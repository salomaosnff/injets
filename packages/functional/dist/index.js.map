{"version":3,"sources":["../src/index.ts"],"names":["Container","ProviderMode","delayed","Token","createResolverFactoryContext","name","currentContainer","depends","containersOrResolvers","resolver","provide","provider","singleton","token","factory","exportProvider","constant","value","transient","inject","createResolverForContainer","container","resolve","tokens","createResolver","context"],"mappings":"AAAA,OAAS,aAAAA,EAAuC,gBAAAC,MAAuC,eAEvF,OACE,WAAAC,EAAS,SAAAC,EAAO,aAAAH,MACX,eAiBP,SAASI,EAA6BC,EAAsC,CAC1E,IAAMC,EAAmB,IAAIN,EAAU,CAAE,KAAAK,CAAK,CAAC,EAE/C,SAASE,KAAWC,EAA2D,CAC7E,QAAWC,KAAYD,EAAuB,CAC5C,GAAIC,aAAoBT,EAAW,CACjCM,EAAiB,OAAOG,CAAQ,EAChC,QACF,CAEA,GAAI,OAAOA,GAAa,YAAcA,EAAS,qBAAqBT,EAAW,CAC7EM,EAAiB,OAAOG,EAAS,SAAS,EAC1C,QACF,CAEA,MAAM,IAAI,UAAU,gCAAgC,CACtD,CACF,CAEA,SAASC,EAAyBC,EAAuB,CACvDL,EAAiB,QAAQK,CAAQ,CACnC,CAEA,SAASC,EAA2BC,EAAiBC,EAAkBC,EAAiB,GAAM,CAC5FT,EAAiB,QAAQ,CACvB,MAAAO,EACA,KAAMZ,EAAa,UACnB,WAAYa,EACZ,OAAQC,CACV,CAAC,CACH,CAEA,SAASC,EAA0BH,EAAiBI,EAAUF,EAAiB,GAAM,CACnFT,EAAiB,QAAQ,CACvB,MAAAO,EACA,SAAUI,EACV,OAAQF,CACV,CAAC,CACH,CAEA,SAASG,EAA2BL,EAAiBC,EAAkBC,EAAiB,GAAM,CAC5FT,EAAiB,QAAQ,CACvB,MAAAO,EACA,WAAYC,EACZ,KAAMb,EAAa,UACnB,OAAQc,CACV,CAAC,CACH,CAEA,SAASI,EAAwBN,EAAyB,CACxD,OAAOP,EAAiB,QAAQO,CAAK,CACvC,CAEA,MAAO,CACL,OAAAM,EACA,QAAAZ,EACA,QAAAG,EACA,UAAAE,EACA,SAAAI,EACA,UAAAE,EACA,UAAWZ,CACb,CACF,CAGO,SAASc,EAA4CC,EAA6C,CACvG,IAAMC,EAA8B,IAAIC,IAAWF,EAAU,QAAQE,CAAM,EAE3E,OAAAD,EAAQ,UAAYD,EAEbC,CACT,CAEO,SAASE,EAAenB,EAAcS,EAAqE,CAChH,IAAMW,EAAUrB,EAA6BC,CAAI,EAEjD,OAAAS,EAAQW,CAAO,EAERL,EAA2BK,EAAQ,SAAS,CACrD","sourcesContent":["import { Container, DependencyValues, Provider, ProviderMode, Token, TokenValue } from '@injets/core';\n\nexport {\n  delayed, Token, Container, \n} from '@injets/core';\n\nexport interface ResolveFunction<T extends Token = Token> {\n  container: Container<T>;\n  <const U extends Readonly<T[]>>(...tokens: U): DependencyValues<U>;\n}\n\nexport interface ResolverFactoryContext {\n  inject<T extends Token>(token: T): TokenValue<T>;\n  depends(...containersOrResolvers: Array<ResolveFunction | Container>): void;\n  provide<T extends Token>(provider: Provider<T>): void;\n  singleton<T extends Token>(token: Token<T>, factory: () => T, exportProvider?: boolean): void;\n  constant<T extends Token>(token: Token<T>, value: T, exportProvider?: boolean): void;\n  transient<T extends Token>(token: Token<T>, factory: () => T, exportProvider?: boolean): void;\n  readonly container: Container;\n}\n\nfunction createResolverFactoryContext(name: string): ResolverFactoryContext {\n  const currentContainer = new Container({ name });\n\n  function depends(...containersOrResolvers: Array<ResolveFunction | Container>) {\n    for (const resolver of containersOrResolvers) {\n      if (resolver instanceof Container) {\n        currentContainer.import(resolver);\n        continue;\n      }\n\n      if (typeof resolver === 'function' && resolver.container instanceof Container) {\n        currentContainer.import(resolver.container);\n        continue;\n      }\n\n      throw new TypeError('Invalid container or resolver.');\n    }\n  }\n\n  function provide<T extends Token>(provider: Provider<T>) {\n    currentContainer.provide(provider);\n  }\n\n  function singleton<T extends Token>(token: Token<T>, factory: () => T, exportProvider = true) {\n    currentContainer.provide({\n      token,\n      mode: ProviderMode.SINGLETON,\n      useFactory: factory,\n      export: exportProvider,\n    });\n  }\n\n  function constant<T extends Token>(token: Token<T>, value: T, exportProvider = true) {\n    currentContainer.provide({\n      token,\n      useValue: value,\n      export: exportProvider,\n    });\n  }\n\n  function transient<T extends Token>(token: Token<T>, factory: () => T, exportProvider = true) {\n    currentContainer.provide({\n      token,\n      useFactory: factory,\n      mode: ProviderMode.TRANSIENT,\n      export: exportProvider,\n    });\n  }\n\n  function inject<T extends Token>(token: T): TokenValue<T> {\n    return currentContainer.resolve(token);\n  }\n\n  return {\n    inject,\n    depends,\n    provide,\n    singleton,\n    constant,\n    transient,\n    container: currentContainer,\n  };\n}\n\n/** Create a resolver function for a existing container. */\nexport function createResolverForContainer<T extends Token>(container: Container<T>): ResolveFunction<T> {\n  const resolve: ResolveFunction<T> = (...tokens) => container.resolve(tokens);\n\n  resolve.container = container;\n\n  return resolve;\n}\n\nexport function createResolver(name: string, factory: (context: ResolverFactoryContext) => void): ResolveFunction {\n  const context = createResolverFactoryContext(name);\n\n  factory(context);\n\n  return createResolverForContainer(context.container);\n}\n"]}